<?php
namespace ThriftTest;

/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
use Thrift\Base\TBase;
use Thrift\Type\TType;
use Thrift\Type\TMessageType;
use Thrift\Exception\TException;
use Thrift\Exception\TProtocolException;
use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TBinaryProtocolAccelerated;
use Thrift\Exception\TApplicationException;


/**
 * Docstring!
 */
final class Numberz {
  const ONE = 1;
  const TWO = 2;
  const THREE = 3;
  const FIVE = 5;
  const SIX = 6;
  const EIGHT = 8;
  static public $__names = array(
    1 => 'ONE',
    2 => 'TWO',
    3 => 'THREE',
    5 => 'FIVE',
    6 => 'SIX',
    8 => 'EIGHT',
  );
}

class Bonk {
  static $_TSPEC;

  /**
   * @var string
   */
  public $message = null;
  /**
   * @var int
   */
  public $type = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'type',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
      if (isset($vals['type'])) {
        $this->type = $vals['type'];
      }
    }
  }

  public function getName() {
    return 'Bonk';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->type);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bonk');
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->type !== null) {
      $xfer += $output->writeFieldBegin('type', TType::I32, 2);
      $xfer += $output->writeI32($this->type);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Bools {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $im_true = null;
  /**
   * @var bool
   */
  public $im_false = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'im_true',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 'im_false',
          'type' => TType::BOOL,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['im_true'])) {
        $this->im_true = $vals['im_true'];
      }
      if (isset($vals['im_false'])) {
        $this->im_false = $vals['im_false'];
      }
    }
  }

  public function getName() {
    return 'Bools';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->im_true);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->im_false);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Bools');
    if ($this->im_true !== null) {
      $xfer += $output->writeFieldBegin('im_true', TType::BOOL, 1);
      $xfer += $output->writeBool($this->im_true);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->im_false !== null) {
      $xfer += $output->writeFieldBegin('im_false', TType::BOOL, 2);
      $xfer += $output->writeBool($this->im_false);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xtruct {
  static $_TSPEC;

  /**
   * @var string
   */
  public $string_thing = null;
  /**
   * @var int
   */
  public $byte_thing = null;
  /**
   * @var int
   */
  public $i32_thing = null;
  /**
   * @var int
   */
  public $i64_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'byte_thing',
          'type' => TType::BYTE,
          ),
        9 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'i64_thing',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['byte_thing'])) {
        $this->byte_thing = $vals['byte_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['i64_thing'])) {
        $this->i64_thing = $vals['i64_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->byte_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->i64_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct');
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->byte_thing !== null) {
      $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 4);
      $xfer += $output->writeByte($this->byte_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64_thing !== null) {
      $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
      $xfer += $output->writeI64($this->i64_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xtruct2 {
  static $_TSPEC;

  /**
   * @var int
   */
  public $byte_thing = null;
  /**
   * @var \ThriftTest\Xtruct
   */
  public $struct_thing = null;
  /**
   * @var int
   */
  public $i32_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'byte_thing',
          'type' => TType::BYTE,
          ),
        2 => array(
          'var' => 'struct_thing',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Xtruct',
          ),
        3 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['byte_thing'])) {
        $this->byte_thing = $vals['byte_thing'];
      }
      if (isset($vals['struct_thing'])) {
        $this->struct_thing = $vals['struct_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->byte_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->struct_thing = new \ThriftTest\Xtruct();
            $xfer += $this->struct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct2');
    if ($this->byte_thing !== null) {
      $xfer += $output->writeFieldBegin('byte_thing', TType::BYTE, 1);
      $xfer += $output->writeByte($this->byte_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->struct_thing !== null) {
      if (!is_object($this->struct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
      $xfer += $this->struct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 3);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xtruct3 {
  static $_TSPEC;

  /**
   * @var string
   */
  public $string_thing = null;
  /**
   * @var int
   */
  public $changed = null;
  /**
   * @var int
   */
  public $i32_thing = null;
  /**
   * @var int
   */
  public $i64_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        4 => array(
          'var' => 'changed',
          'type' => TType::I32,
          ),
        9 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        11 => array(
          'var' => 'i64_thing',
          'type' => TType::I64,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['changed'])) {
        $this->changed = $vals['changed'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['i64_thing'])) {
        $this->i64_thing = $vals['i64_thing'];
      }
    }
  }

  public function getName() {
    return 'Xtruct3';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->changed);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->i64_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xtruct3');
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 1);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->changed !== null) {
      $xfer += $output->writeFieldBegin('changed', TType::I32, 4);
      $xfer += $output->writeI32($this->changed);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 9);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i64_thing !== null) {
      $xfer += $output->writeFieldBegin('i64_thing', TType::I64, 11);
      $xfer += $output->writeI64($this->i64_thing);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Insanity {
  static $_TSPEC;

  /**
   * @var array
   */
  public $userMap = null;
  /**
   * @var \ThriftTest\Xtruct[]
   */
  public $xtructs = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'userMap',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'xtructs',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftTest\Xtruct',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['userMap'])) {
        $this->userMap = $vals['userMap'];
      }
      if (isset($vals['xtructs'])) {
        $this->xtructs = $vals['xtructs'];
      }
    }
  }

  public function getName() {
    return 'Insanity';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->userMap = array();
            $_size0 = 0;
            $_ktype1 = 0;
            $_vtype2 = 0;
            $xfer += $input->readMapBegin($_ktype1, $_vtype2, $_size0);
            for ($_i4 = 0; $_i4 < $_size0; ++$_i4)
            {
              $key5 = 0;
              $val6 = 0;
              $xfer += $input->readI32($key5);
              $xfer += $input->readI64($val6);
              $this->userMap[$key5] = $val6;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::LST) {
            $this->xtructs = array();
            $_size7 = 0;
            $_etype10 = 0;
            $xfer += $input->readListBegin($_etype10, $_size7);
            for ($_i11 = 0; $_i11 < $_size7; ++$_i11)
            {
              $elem12 = null;
              $elem12 = new \ThriftTest\Xtruct();
              $xfer += $elem12->read($input);
              $this->xtructs []= $elem12;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Insanity');
    if ($this->userMap !== null) {
      if (!is_array($this->userMap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('userMap', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I32, TType::I64, count($this->userMap));
        {
          foreach ($this->userMap as $kiter13 => $viter14)
          {
            $xfer += $output->writeI32($kiter13);
            $xfer += $output->writeI64($viter14);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->xtructs !== null) {
      if (!is_array($this->xtructs)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('xtructs', TType::LST, 2);
      {
        $output->writeListBegin(TType::STRUCT, count($this->xtructs));
        {
          foreach ($this->xtructs as $iter15)
          {
            $xfer += $iter15->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class CrazyNesting {
  static $_TSPEC;

  /**
   * @var string
   */
  public $string_field = null;
  /**
   * @var \ThriftTest\Insanity[]
   */
  public $set_field = null;
  /**
   * @var (array)[]
   */
  public $list_field = null;
  /**
   * @var string
   */
  public $binary_field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'string_field',
          'type' => TType::STRING,
          ),
        2 => array(
          'var' => 'set_field',
          'type' => TType::SET,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftTest\Insanity',
            ),
          ),
        3 => array(
          'var' => 'list_field',
          'type' => TType::LST,
          'etype' => TType::MAP,
          'elem' => array(
            'type' => TType::MAP,
            'ktype' => TType::SET,
            'vtype' => TType::MAP,
            'key' => array(
              'type' => TType::SET,
              'etype' => TType::I32,
              'elem' => array(
                'type' => TType::I32,
                ),
            ),
            'val' => array(
              'type' => TType::MAP,
              'ktype' => TType::I32,
              'vtype' => TType::SET,
              'key' => array(
                'type' => TType::I32,
              ),
              'val' => array(
                'type' => TType::SET,
                'etype' => TType::LST,
                'elem' => array(
                  'type' => TType::LST,
                  'etype' => TType::MAP,
                  'elem' => array(
                    'type' => TType::MAP,
                    'ktype' => TType::STRUCT,
                    'vtype' => TType::STRING,
                    'key' => array(
                      'type' => TType::STRUCT,
                      'class' => '\ThriftTest\Insanity',
                    ),
                    'val' => array(
                      'type' => TType::STRING,
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        4 => array(
          'var' => 'binary_field',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['string_field'])) {
        $this->string_field = $vals['string_field'];
      }
      if (isset($vals['set_field'])) {
        $this->set_field = $vals['set_field'];
      }
      if (isset($vals['list_field'])) {
        $this->list_field = $vals['list_field'];
      }
      if (isset($vals['binary_field'])) {
        $this->binary_field = $vals['binary_field'];
      }
    }
  }

  public function getName() {
    return 'CrazyNesting';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::SET) {
            $this->set_field = array();
            $_size16 = 0;
            $_etype19 = 0;
            $xfer += $input->readSetBegin($_etype19, $_size16);
            for ($_i20 = 0; $_i20 < $_size16; ++$_i20)
            {
              $elem21 = null;
              $elem21 = new \ThriftTest\Insanity();
              $xfer += $elem21->read($input);
              if (is_scalar($elem21)) {
                $this->set_field[$elem21] = true;
              } else {
                $this->set_field []= $elem21;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->list_field = array();
            $_size22 = 0;
            $_etype25 = 0;
            $xfer += $input->readListBegin($_etype25, $_size22);
            for ($_i26 = 0; $_i26 < $_size22; ++$_i26)
            {
              $elem27 = null;
              $elem27 = array();
              $_size28 = 0;
              $_ktype29 = 0;
              $_vtype30 = 0;
              $xfer += $input->readMapBegin($_ktype29, $_vtype30, $_size28);
              for ($_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                $key33 = array();
                $val34 = array();
                $key33 = array();
                $_size35 = 0;
                $_etype38 = 0;
                $xfer += $input->readSetBegin($_etype38, $_size35);
                for ($_i39 = 0; $_i39 < $_size35; ++$_i39)
                {
                  $elem40 = null;
                  $xfer += $input->readI32($elem40);
                  if (is_scalar($elem40)) {
                    $key33[$elem40] = true;
                  } else {
                    $key33 []= $elem40;
                  }
                }
                $xfer += $input->readSetEnd();
                $val34 = array();
                $_size41 = 0;
                $_ktype42 = 0;
                $_vtype43 = 0;
                $xfer += $input->readMapBegin($_ktype42, $_vtype43, $_size41);
                for ($_i45 = 0; $_i45 < $_size41; ++$_i45)
                {
                  $key46 = 0;
                  $val47 = array();
                  $xfer += $input->readI32($key46);
                  $val47 = array();
                  $_size48 = 0;
                  $_etype51 = 0;
                  $xfer += $input->readSetBegin($_etype51, $_size48);
                  for ($_i52 = 0; $_i52 < $_size48; ++$_i52)
                  {
                    $elem53 = null;
                    $elem53 = array();
                    $_size54 = 0;
                    $_etype57 = 0;
                    $xfer += $input->readListBegin($_etype57, $_size54);
                    for ($_i58 = 0; $_i58 < $_size54; ++$_i58)
                    {
                      $elem59 = null;
                      $elem59 = array();
                      $_size60 = 0;
                      $_ktype61 = 0;
                      $_vtype62 = 0;
                      $xfer += $input->readMapBegin($_ktype61, $_vtype62, $_size60);
                      for ($_i64 = 0; $_i64 < $_size60; ++$_i64)
                      {
                        $key65 = new \ThriftTest\Insanity();
                        $val66 = '';
                        $key65 = new \ThriftTest\Insanity();
                        $xfer += $key65->read($input);
                        $xfer += $input->readString($val66);
                        $elem59[$key65] = $val66;
                      }
                      $xfer += $input->readMapEnd();
                      $elem53 []= $elem59;
                    }
                    $xfer += $input->readListEnd();
                    if (is_scalar($elem53)) {
                      $val47[$elem53] = true;
                    } else {
                      $val47 []= $elem53;
                    }
                  }
                  $xfer += $input->readSetEnd();
                  $val34[$key46] = $val47;
                }
                $xfer += $input->readMapEnd();
                $elem27[$key33] = $val34;
              }
              $xfer += $input->readMapEnd();
              $this->list_field []= $elem27;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->binary_field);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('CrazyNesting');
    if ($this->string_field !== null) {
      $xfer += $output->writeFieldBegin('string_field', TType::STRING, 1);
      $xfer += $output->writeString($this->string_field);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->set_field !== null) {
      if (!is_array($this->set_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('set_field', TType::SET, 2);
      {
        $output->writeSetBegin(TType::STRUCT, count($this->set_field));
        {
          foreach ($this->set_field as $iter67 => $iter68)
          {
            if (is_scalar($iter68)) {
            $xfer += $iter67->write($output);
            } else {
            $xfer += $iter68->write($output);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->list_field !== null) {
      if (!is_array($this->list_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('list_field', TType::LST, 3);
      {
        $output->writeListBegin(TType::MAP, count($this->list_field));
        {
          foreach ($this->list_field as $iter69)
          {
            {
              $output->writeMapBegin(TType::SET, TType::MAP, count($iter69));
              {
                foreach ($iter69 as $kiter70 => $viter71)
                {
                  {
                    $output->writeSetBegin(TType::I32, count($kiter70));
                    {
                      foreach ($kiter70 as $iter72 => $iter73)
                      {
                        if (is_scalar($iter73)) {
                        $xfer += $output->writeI32($iter72);
                        } else {
                        $xfer += $output->writeI32($iter73);
                        }
                      }
                    }
                    $output->writeSetEnd();
                  }
                  {
                    $output->writeMapBegin(TType::I32, TType::SET, count($viter71));
                    {
                      foreach ($viter71 as $kiter74 => $viter75)
                      {
                        $xfer += $output->writeI32($kiter74);
                        {
                          $output->writeSetBegin(TType::LST, count($viter75));
                          {
                            foreach ($viter75 as $iter76 => $iter77)
                            {
                              if (is_scalar($iter77)) {
                              {
                                $output->writeListBegin(TType::MAP, count($iter76));
                                {
                                  foreach ($iter76 as $iter78)
                                  {
                                    {
                                      $output->writeMapBegin(TType::STRUCT, TType::STRING, count($iter78));
                                      {
                                        foreach ($iter78 as $kiter79 => $viter80)
                                        {
                                          $xfer += $kiter79->write($output);
                                          $xfer += $output->writeString($viter80);
                                        }
                                      }
                                      $output->writeMapEnd();
                                    }
                                  }
                                }
                                $output->writeListEnd();
                              }
                              } else {
                              {
                                $output->writeListBegin(TType::MAP, count($iter77));
                                {
                                  foreach ($iter77 as $iter81)
                                  {
                                    {
                                      $output->writeMapBegin(TType::STRUCT, TType::STRING, count($iter81));
                                      {
                                        foreach ($iter81 as $kiter82 => $viter83)
                                        {
                                          $xfer += $kiter82->write($output);
                                          $xfer += $output->writeString($viter83);
                                        }
                                      }
                                      $output->writeMapEnd();
                                    }
                                  }
                                }
                                $output->writeListEnd();
                              }
                              }
                            }
                          }
                          $output->writeSetEnd();
                        }
                      }
                    }
                    $output->writeMapEnd();
                  }
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->binary_field !== null) {
      $xfer += $output->writeFieldBegin('binary_field', TType::STRING, 4);
      $xfer += $output->writeString($this->binary_field);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class SomeUnion {
  static $_TSPEC;

  /**
   * @var array
   */
  public $map_thing = null;
  /**
   * @var string
   */
  public $string_thing = null;
  /**
   * @var int
   */
  public $i32_thing = null;
  /**
   * @var \ThriftTest\Xtruct3
   */
  public $xtruct_thing = null;
  /**
   * @var \ThriftTest\Insanity
   */
  public $insanity_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'map_thing',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I64,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I64,
            ),
          ),
        2 => array(
          'var' => 'string_thing',
          'type' => TType::STRING,
          ),
        3 => array(
          'var' => 'i32_thing',
          'type' => TType::I32,
          ),
        4 => array(
          'var' => 'xtruct_thing',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Xtruct3',
          ),
        5 => array(
          'var' => 'insanity_thing',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Insanity',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['map_thing'])) {
        $this->map_thing = $vals['map_thing'];
      }
      if (isset($vals['string_thing'])) {
        $this->string_thing = $vals['string_thing'];
      }
      if (isset($vals['i32_thing'])) {
        $this->i32_thing = $vals['i32_thing'];
      }
      if (isset($vals['xtruct_thing'])) {
        $this->xtruct_thing = $vals['xtruct_thing'];
      }
      if (isset($vals['insanity_thing'])) {
        $this->insanity_thing = $vals['insanity_thing'];
      }
    }
  }

  public function getName() {
    return 'SomeUnion';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::MAP) {
            $this->map_thing = array();
            $_size84 = 0;
            $_ktype85 = 0;
            $_vtype86 = 0;
            $xfer += $input->readMapBegin($_ktype85, $_vtype86, $_size84);
            for ($_i88 = 0; $_i88 < $_size84; ++$_i88)
            {
              $key89 = 0;
              $val90 = 0;
              $xfer += $input->readI32($key89);
              $xfer += $input->readI64($val90);
              $this->map_thing[$key89] = $val90;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->string_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->i32_thing);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::STRUCT) {
            $this->xtruct_thing = new \ThriftTest\Xtruct3();
            $xfer += $this->xtruct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::STRUCT) {
            $this->insanity_thing = new \ThriftTest\Insanity();
            $xfer += $this->insanity_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('SomeUnion');
    if ($this->map_thing !== null) {
      if (!is_array($this->map_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_thing', TType::MAP, 1);
      {
        $output->writeMapBegin(TType::I32, TType::I64, count($this->map_thing));
        {
          foreach ($this->map_thing as $kiter91 => $viter92)
          {
            $xfer += $output->writeI32($kiter91);
            $xfer += $output->writeI64($viter92);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->string_thing !== null) {
      $xfer += $output->writeFieldBegin('string_thing', TType::STRING, 2);
      $xfer += $output->writeString($this->string_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->i32_thing !== null) {
      $xfer += $output->writeFieldBegin('i32_thing', TType::I32, 3);
      $xfer += $output->writeI32($this->i32_thing);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->xtruct_thing !== null) {
      if (!is_object($this->xtruct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('xtruct_thing', TType::STRUCT, 4);
      $xfer += $this->xtruct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->insanity_thing !== null) {
      if (!is_object($this->insanity_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('insanity_thing', TType::STRUCT, 5);
      $xfer += $this->insanity_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xception extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $errorCode = null;
  /**
   * @var string
   */
  public $message = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'message',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['message'])) {
        $this->message = $vals['message'];
      }
    }
  }

  public function getName() {
    return 'Xception';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->message);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xception');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->message !== null) {
      $xfer += $output->writeFieldBegin('message', TType::STRING, 2);
      $xfer += $output->writeString($this->message);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class Xception2 extends TException {
  static $_TSPEC;

  /**
   * @var int
   */
  public $errorCode = null;
  /**
   * @var \ThriftTest\Xtruct
   */
  public $struct_thing = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'errorCode',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'struct_thing',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Xtruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['errorCode'])) {
        $this->errorCode = $vals['errorCode'];
      }
      if (isset($vals['struct_thing'])) {
        $this->struct_thing = $vals['struct_thing'];
      }
    }
  }

  public function getName() {
    return 'Xception2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->errorCode);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->struct_thing = new \ThriftTest\Xtruct();
            $xfer += $this->struct_thing->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('Xception2');
    if ($this->errorCode !== null) {
      $xfer += $output->writeFieldBegin('errorCode', TType::I32, 1);
      $xfer += $output->writeI32($this->errorCode);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->struct_thing !== null) {
      if (!is_object($this->struct_thing)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('struct_thing', TType::STRUCT, 2);
      $xfer += $this->struct_thing->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class EmptyStruct {
  static $_TSPEC;


  public function __construct() {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        );
    }
  }

  public function getName() {
    return 'EmptyStruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('EmptyStruct');
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class OneField {
  static $_TSPEC;

  /**
   * @var \ThriftTest\EmptyStruct
   */
  public $field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'field',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\EmptyStruct',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['field'])) {
        $this->field = $vals['field'];
      }
    }
  }

  public function getName() {
    return 'OneField';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->field = new \ThriftTest\EmptyStruct();
            $xfer += $this->field->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('OneField');
    if ($this->field !== null) {
      if (!is_object($this->field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('field', TType::STRUCT, 1);
      $xfer += $this->field->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class VersioningTestV1 {
  static $_TSPEC;

  /**
   * @var int
   */
  public $begin_in_both = null;
  /**
   * @var string
   */
  public $old_string = null;
  /**
   * @var int
   */
  public $end_in_both = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'begin_in_both',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'old_string',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'end_in_both',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['begin_in_both'])) {
        $this->begin_in_both = $vals['begin_in_both'];
      }
      if (isset($vals['old_string'])) {
        $this->old_string = $vals['old_string'];
      }
      if (isset($vals['end_in_both'])) {
        $this->end_in_both = $vals['end_in_both'];
      }
    }
  }

  public function getName() {
    return 'VersioningTestV1';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->begin_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->old_string);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->end_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VersioningTestV1');
    if ($this->begin_in_both !== null) {
      $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
      $xfer += $output->writeI32($this->begin_in_both);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->old_string !== null) {
      $xfer += $output->writeFieldBegin('old_string', TType::STRING, 3);
      $xfer += $output->writeString($this->old_string);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_in_both !== null) {
      $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
      $xfer += $output->writeI32($this->end_in_both);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class VersioningTestV2 {
  static $_TSPEC;

  /**
   * @var int
   */
  public $begin_in_both = null;
  /**
   * @var int
   */
  public $newint = null;
  /**
   * @var int
   */
  public $newbyte = null;
  /**
   * @var int
   */
  public $newshort = null;
  /**
   * @var int
   */
  public $newlong = null;
  /**
   * @var double
   */
  public $newdouble = null;
  /**
   * @var \ThriftTest\Bonk
   */
  public $newstruct = null;
  /**
   * @var int[]
   */
  public $newlist = null;
  /**
   * @var int[]
   */
  public $newset = null;
  /**
   * @var array
   */
  public $newmap = null;
  /**
   * @var string
   */
  public $newstring = null;
  /**
   * @var int
   */
  public $end_in_both = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'begin_in_both',
          'type' => TType::I32,
          ),
        2 => array(
          'var' => 'newint',
          'type' => TType::I32,
          ),
        3 => array(
          'var' => 'newbyte',
          'type' => TType::BYTE,
          ),
        4 => array(
          'var' => 'newshort',
          'type' => TType::I16,
          ),
        5 => array(
          'var' => 'newlong',
          'type' => TType::I64,
          ),
        6 => array(
          'var' => 'newdouble',
          'type' => TType::DOUBLE,
          ),
        7 => array(
          'var' => 'newstruct',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bonk',
          ),
        8 => array(
          'var' => 'newlist',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        9 => array(
          'var' => 'newset',
          'type' => TType::SET,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        10 => array(
          'var' => 'newmap',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::I32,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::I32,
            ),
          ),
        11 => array(
          'var' => 'newstring',
          'type' => TType::STRING,
          ),
        12 => array(
          'var' => 'end_in_both',
          'type' => TType::I32,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['begin_in_both'])) {
        $this->begin_in_both = $vals['begin_in_both'];
      }
      if (isset($vals['newint'])) {
        $this->newint = $vals['newint'];
      }
      if (isset($vals['newbyte'])) {
        $this->newbyte = $vals['newbyte'];
      }
      if (isset($vals['newshort'])) {
        $this->newshort = $vals['newshort'];
      }
      if (isset($vals['newlong'])) {
        $this->newlong = $vals['newlong'];
      }
      if (isset($vals['newdouble'])) {
        $this->newdouble = $vals['newdouble'];
      }
      if (isset($vals['newstruct'])) {
        $this->newstruct = $vals['newstruct'];
      }
      if (isset($vals['newlist'])) {
        $this->newlist = $vals['newlist'];
      }
      if (isset($vals['newset'])) {
        $this->newset = $vals['newset'];
      }
      if (isset($vals['newmap'])) {
        $this->newmap = $vals['newmap'];
      }
      if (isset($vals['newstring'])) {
        $this->newstring = $vals['newstring'];
      }
      if (isset($vals['end_in_both'])) {
        $this->end_in_both = $vals['end_in_both'];
      }
    }
  }

  public function getName() {
    return 'VersioningTestV2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->begin_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->newint);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::BYTE) {
            $xfer += $input->readByte($this->newbyte);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4:
          if ($ftype == TType::I16) {
            $xfer += $input->readI16($this->newshort);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 5:
          if ($ftype == TType::I64) {
            $xfer += $input->readI64($this->newlong);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 6:
          if ($ftype == TType::DOUBLE) {
            $xfer += $input->readDouble($this->newdouble);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 7:
          if ($ftype == TType::STRUCT) {
            $this->newstruct = new \ThriftTest\Bonk();
            $xfer += $this->newstruct->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 8:
          if ($ftype == TType::LST) {
            $this->newlist = array();
            $_size93 = 0;
            $_etype96 = 0;
            $xfer += $input->readListBegin($_etype96, $_size93);
            for ($_i97 = 0; $_i97 < $_size93; ++$_i97)
            {
              $elem98 = null;
              $xfer += $input->readI32($elem98);
              $this->newlist []= $elem98;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 9:
          if ($ftype == TType::SET) {
            $this->newset = array();
            $_size99 = 0;
            $_etype102 = 0;
            $xfer += $input->readSetBegin($_etype102, $_size99);
            for ($_i103 = 0; $_i103 < $_size99; ++$_i103)
            {
              $elem104 = null;
              $xfer += $input->readI32($elem104);
              if (is_scalar($elem104)) {
                $this->newset[$elem104] = true;
              } else {
                $this->newset []= $elem104;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::MAP) {
            $this->newmap = array();
            $_size105 = 0;
            $_ktype106 = 0;
            $_vtype107 = 0;
            $xfer += $input->readMapBegin($_ktype106, $_vtype107, $_size105);
            for ($_i109 = 0; $_i109 < $_size105; ++$_i109)
            {
              $key110 = 0;
              $val111 = 0;
              $xfer += $input->readI32($key110);
              $xfer += $input->readI32($val111);
              $this->newmap[$key110] = $val111;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 11:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->newstring);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 12:
          if ($ftype == TType::I32) {
            $xfer += $input->readI32($this->end_in_both);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('VersioningTestV2');
    if ($this->begin_in_both !== null) {
      $xfer += $output->writeFieldBegin('begin_in_both', TType::I32, 1);
      $xfer += $output->writeI32($this->begin_in_both);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newint !== null) {
      $xfer += $output->writeFieldBegin('newint', TType::I32, 2);
      $xfer += $output->writeI32($this->newint);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newbyte !== null) {
      $xfer += $output->writeFieldBegin('newbyte', TType::BYTE, 3);
      $xfer += $output->writeByte($this->newbyte);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newshort !== null) {
      $xfer += $output->writeFieldBegin('newshort', TType::I16, 4);
      $xfer += $output->writeI16($this->newshort);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newlong !== null) {
      $xfer += $output->writeFieldBegin('newlong', TType::I64, 5);
      $xfer += $output->writeI64($this->newlong);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newdouble !== null) {
      $xfer += $output->writeFieldBegin('newdouble', TType::DOUBLE, 6);
      $xfer += $output->writeDouble($this->newdouble);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newstruct !== null) {
      if (!is_object($this->newstruct)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newstruct', TType::STRUCT, 7);
      $xfer += $this->newstruct->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newlist !== null) {
      if (!is_array($this->newlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newlist', TType::LST, 8);
      {
        $output->writeListBegin(TType::I32, count($this->newlist));
        {
          foreach ($this->newlist as $iter112)
          {
            $xfer += $output->writeI32($iter112);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newset !== null) {
      if (!is_array($this->newset)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newset', TType::SET, 9);
      {
        $output->writeSetBegin(TType::I32, count($this->newset));
        {
          foreach ($this->newset as $iter113 => $iter114)
          {
            if (is_scalar($iter114)) {
            $xfer += $output->writeI32($iter113);
            } else {
            $xfer += $output->writeI32($iter114);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newmap !== null) {
      if (!is_array($this->newmap)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('newmap', TType::MAP, 10);
      {
        $output->writeMapBegin(TType::I32, TType::I32, count($this->newmap));
        {
          foreach ($this->newmap as $kiter115 => $viter116)
          {
            $xfer += $output->writeI32($kiter115);
            $xfer += $output->writeI32($viter116);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->newstring !== null) {
      $xfer += $output->writeFieldBegin('newstring', TType::STRING, 11);
      $xfer += $output->writeString($this->newstring);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->end_in_both !== null) {
      $xfer += $output->writeFieldBegin('end_in_both', TType::I32, 12);
      $xfer += $output->writeI32($this->end_in_both);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTypeVersioningV1 {
  static $_TSPEC;

  /**
   * @var int[]
   */
  public $myints = null;
  /**
   * @var string
   */
  public $hello = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'myints',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        2 => array(
          'var' => 'hello',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['myints'])) {
        $this->myints = $vals['myints'];
      }
      if (isset($vals['hello'])) {
        $this->hello = $vals['hello'];
      }
    }
  }

  public function getName() {
    return 'ListTypeVersioningV1';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->myints = array();
            $_size117 = 0;
            $_etype120 = 0;
            $xfer += $input->readListBegin($_etype120, $_size117);
            for ($_i121 = 0; $_i121 < $_size117; ++$_i121)
            {
              $elem122 = null;
              $xfer += $input->readI32($elem122);
              $this->myints []= $elem122;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hello);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTypeVersioningV1');
    if ($this->myints !== null) {
      if (!is_array($this->myints)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('myints', TType::LST, 1);
      {
        $output->writeListBegin(TType::I32, count($this->myints));
        {
          foreach ($this->myints as $iter123)
          {
            $xfer += $output->writeI32($iter123);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hello !== null) {
      $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
      $xfer += $output->writeString($this->hello);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListTypeVersioningV2 {
  static $_TSPEC;

  /**
   * @var string[]
   */
  public $strings = null;
  /**
   * @var string
   */
  public $hello = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'strings',
          'type' => TType::LST,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        2 => array(
          'var' => 'hello',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['strings'])) {
        $this->strings = $vals['strings'];
      }
      if (isset($vals['hello'])) {
        $this->hello = $vals['hello'];
      }
    }
  }

  public function getName() {
    return 'ListTypeVersioningV2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->strings = array();
            $_size124 = 0;
            $_etype127 = 0;
            $xfer += $input->readListBegin($_etype127, $_size124);
            for ($_i128 = 0; $_i128 < $_size124; ++$_i128)
            {
              $elem129 = null;
              $xfer += $input->readString($elem129);
              $this->strings []= $elem129;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->hello);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListTypeVersioningV2');
    if ($this->strings !== null) {
      if (!is_array($this->strings)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('strings', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRING, count($this->strings));
        {
          foreach ($this->strings as $iter130)
          {
            $xfer += $output->writeString($iter130);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->hello !== null) {
      $xfer += $output->writeFieldBegin('hello', TType::STRING, 2);
      $xfer += $output->writeString($this->hello);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class GuessProtocolStruct {
  static $_TSPEC;

  /**
   * @var array
   */
  public $map_field = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        7 => array(
          'var' => 'map_field',
          'type' => TType::MAP,
          'ktype' => TType::STRING,
          'vtype' => TType::STRING,
          'key' => array(
            'type' => TType::STRING,
          ),
          'val' => array(
            'type' => TType::STRING,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['map_field'])) {
        $this->map_field = $vals['map_field'];
      }
    }
  }

  public function getName() {
    return 'GuessProtocolStruct';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 7:
          if ($ftype == TType::MAP) {
            $this->map_field = array();
            $_size131 = 0;
            $_ktype132 = 0;
            $_vtype133 = 0;
            $xfer += $input->readMapBegin($_ktype132, $_vtype133, $_size131);
            for ($_i135 = 0; $_i135 < $_size131; ++$_i135)
            {
              $key136 = '';
              $val137 = '';
              $xfer += $input->readString($key136);
              $xfer += $input->readString($val137);
              $this->map_field[$key136] = $val137;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('GuessProtocolStruct');
    if ($this->map_field !== null) {
      if (!is_array($this->map_field)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_field', TType::MAP, 7);
      {
        $output->writeMapBegin(TType::STRING, TType::STRING, count($this->map_field));
        {
          foreach ($this->map_field as $kiter138 => $viter139)
          {
            $xfer += $output->writeString($kiter138);
            $xfer += $output->writeString($viter139);
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class LargeDeltas {
  static $_TSPEC;

  /**
   * @var \ThriftTest\Bools
   */
  public $b1 = null;
  /**
   * @var \ThriftTest\Bools
   */
  public $b10 = null;
  /**
   * @var \ThriftTest\Bools
   */
  public $b100 = null;
  /**
   * @var bool
   */
  public $check_true = null;
  /**
   * @var \ThriftTest\Bools
   */
  public $b1000 = null;
  /**
   * @var bool
   */
  public $check_false = null;
  /**
   * @var \ThriftTest\VersioningTestV2
   */
  public $vertwo2000 = null;
  /**
   * @var string[]
   */
  public $a_set2500 = null;
  /**
   * @var \ThriftTest\VersioningTestV2
   */
  public $vertwo3000 = null;
  /**
   * @var int[]
   */
  public $big_numbers = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'b1',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        10 => array(
          'var' => 'b10',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        100 => array(
          'var' => 'b100',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        500 => array(
          'var' => 'check_true',
          'type' => TType::BOOL,
          ),
        1000 => array(
          'var' => 'b1000',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\Bools',
          ),
        1500 => array(
          'var' => 'check_false',
          'type' => TType::BOOL,
          ),
        2000 => array(
          'var' => 'vertwo2000',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\VersioningTestV2',
          ),
        2500 => array(
          'var' => 'a_set2500',
          'type' => TType::SET,
          'etype' => TType::STRING,
          'elem' => array(
            'type' => TType::STRING,
            ),
          ),
        3000 => array(
          'var' => 'vertwo3000',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\VersioningTestV2',
          ),
        4000 => array(
          'var' => 'big_numbers',
          'type' => TType::LST,
          'etype' => TType::I32,
          'elem' => array(
            'type' => TType::I32,
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['b1'])) {
        $this->b1 = $vals['b1'];
      }
      if (isset($vals['b10'])) {
        $this->b10 = $vals['b10'];
      }
      if (isset($vals['b100'])) {
        $this->b100 = $vals['b100'];
      }
      if (isset($vals['check_true'])) {
        $this->check_true = $vals['check_true'];
      }
      if (isset($vals['b1000'])) {
        $this->b1000 = $vals['b1000'];
      }
      if (isset($vals['check_false'])) {
        $this->check_false = $vals['check_false'];
      }
      if (isset($vals['vertwo2000'])) {
        $this->vertwo2000 = $vals['vertwo2000'];
      }
      if (isset($vals['a_set2500'])) {
        $this->a_set2500 = $vals['a_set2500'];
      }
      if (isset($vals['vertwo3000'])) {
        $this->vertwo3000 = $vals['vertwo3000'];
      }
      if (isset($vals['big_numbers'])) {
        $this->big_numbers = $vals['big_numbers'];
      }
    }
  }

  public function getName() {
    return 'LargeDeltas';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->b1 = new \ThriftTest\Bools();
            $xfer += $this->b1->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 10:
          if ($ftype == TType::STRUCT) {
            $this->b10 = new \ThriftTest\Bools();
            $xfer += $this->b10->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 100:
          if ($ftype == TType::STRUCT) {
            $this->b100 = new \ThriftTest\Bools();
            $xfer += $this->b100->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 500:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->check_true);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1000:
          if ($ftype == TType::STRUCT) {
            $this->b1000 = new \ThriftTest\Bools();
            $xfer += $this->b1000->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 1500:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->check_false);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2000:
          if ($ftype == TType::STRUCT) {
            $this->vertwo2000 = new \ThriftTest\VersioningTestV2();
            $xfer += $this->vertwo2000->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2500:
          if ($ftype == TType::SET) {
            $this->a_set2500 = array();
            $_size140 = 0;
            $_etype143 = 0;
            $xfer += $input->readSetBegin($_etype143, $_size140);
            for ($_i144 = 0; $_i144 < $_size140; ++$_i144)
            {
              $elem145 = null;
              $xfer += $input->readString($elem145);
              if (is_scalar($elem145)) {
                $this->a_set2500[$elem145] = true;
              } else {
                $this->a_set2500 []= $elem145;
              }
            }
            $xfer += $input->readSetEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3000:
          if ($ftype == TType::STRUCT) {
            $this->vertwo3000 = new \ThriftTest\VersioningTestV2();
            $xfer += $this->vertwo3000->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 4000:
          if ($ftype == TType::LST) {
            $this->big_numbers = array();
            $_size146 = 0;
            $_etype149 = 0;
            $xfer += $input->readListBegin($_etype149, $_size146);
            for ($_i150 = 0; $_i150 < $_size146; ++$_i150)
            {
              $elem151 = null;
              $xfer += $input->readI32($elem151);
              $this->big_numbers []= $elem151;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('LargeDeltas');
    if ($this->b1 !== null) {
      if (!is_object($this->b1)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b1', TType::STRUCT, 1);
      $xfer += $this->b1->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->b10 !== null) {
      if (!is_object($this->b10)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b10', TType::STRUCT, 10);
      $xfer += $this->b10->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->b100 !== null) {
      if (!is_object($this->b100)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b100', TType::STRUCT, 100);
      $xfer += $this->b100->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->check_true !== null) {
      $xfer += $output->writeFieldBegin('check_true', TType::BOOL, 500);
      $xfer += $output->writeBool($this->check_true);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->b1000 !== null) {
      if (!is_object($this->b1000)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('b1000', TType::STRUCT, 1000);
      $xfer += $this->b1000->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->check_false !== null) {
      $xfer += $output->writeFieldBegin('check_false', TType::BOOL, 1500);
      $xfer += $output->writeBool($this->check_false);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->vertwo2000 !== null) {
      if (!is_object($this->vertwo2000)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('vertwo2000', TType::STRUCT, 2000);
      $xfer += $this->vertwo2000->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->a_set2500 !== null) {
      if (!is_array($this->a_set2500)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('a_set2500', TType::SET, 2500);
      {
        $output->writeSetBegin(TType::STRING, count($this->a_set2500));
        {
          foreach ($this->a_set2500 as $iter152 => $iter153)
          {
            if (is_scalar($iter153)) {
            $xfer += $output->writeString($iter152);
            } else {
            $xfer += $output->writeString($iter153);
            }
          }
        }
        $output->writeSetEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->vertwo3000 !== null) {
      if (!is_object($this->vertwo3000)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('vertwo3000', TType::STRUCT, 3000);
      $xfer += $this->vertwo3000->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->big_numbers !== null) {
      if (!is_array($this->big_numbers)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('big_numbers', TType::LST, 4000);
      {
        $output->writeListBegin(TType::I32, count($this->big_numbers));
        {
          foreach ($this->big_numbers as $iter154)
          {
            $xfer += $output->writeI32($iter154);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedListsI32x2 {
  static $_TSPEC;

  /**
   * @var (int[])[]
   */
  public $integerlist = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'integerlist',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::I32,
            'elem' => array(
              'type' => TType::I32,
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['integerlist'])) {
        $this->integerlist = $vals['integerlist'];
      }
    }
  }

  public function getName() {
    return 'NestedListsI32x2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->integerlist = array();
            $_size155 = 0;
            $_etype158 = 0;
            $xfer += $input->readListBegin($_etype158, $_size155);
            for ($_i159 = 0; $_i159 < $_size155; ++$_i159)
            {
              $elem160 = null;
              $elem160 = array();
              $_size161 = 0;
              $_etype164 = 0;
              $xfer += $input->readListBegin($_etype164, $_size161);
              for ($_i165 = 0; $_i165 < $_size161; ++$_i165)
              {
                $elem166 = null;
                $xfer += $input->readI32($elem166);
                $elem160 []= $elem166;
              }
              $xfer += $input->readListEnd();
              $this->integerlist []= $elem160;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedListsI32x2');
    if ($this->integerlist !== null) {
      if (!is_array($this->integerlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('integerlist', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->integerlist));
        {
          foreach ($this->integerlist as $iter167)
          {
            {
              $output->writeListBegin(TType::I32, count($iter167));
              {
                foreach ($iter167 as $iter168)
                {
                  $xfer += $output->writeI32($iter168);
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedListsI32x3 {
  static $_TSPEC;

  /**
   * @var ((int[])[])[]
   */
  public $integerlist = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'integerlist',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::LST,
            'elem' => array(
              'type' => TType::LST,
              'etype' => TType::I32,
              'elem' => array(
                'type' => TType::I32,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['integerlist'])) {
        $this->integerlist = $vals['integerlist'];
      }
    }
  }

  public function getName() {
    return 'NestedListsI32x3';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->integerlist = array();
            $_size169 = 0;
            $_etype172 = 0;
            $xfer += $input->readListBegin($_etype172, $_size169);
            for ($_i173 = 0; $_i173 < $_size169; ++$_i173)
            {
              $elem174 = null;
              $elem174 = array();
              $_size175 = 0;
              $_etype178 = 0;
              $xfer += $input->readListBegin($_etype178, $_size175);
              for ($_i179 = 0; $_i179 < $_size175; ++$_i179)
              {
                $elem180 = null;
                $elem180 = array();
                $_size181 = 0;
                $_etype184 = 0;
                $xfer += $input->readListBegin($_etype184, $_size181);
                for ($_i185 = 0; $_i185 < $_size181; ++$_i185)
                {
                  $elem186 = null;
                  $xfer += $input->readI32($elem186);
                  $elem180 []= $elem186;
                }
                $xfer += $input->readListEnd();
                $elem174 []= $elem180;
              }
              $xfer += $input->readListEnd();
              $this->integerlist []= $elem174;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedListsI32x3');
    if ($this->integerlist !== null) {
      if (!is_array($this->integerlist)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('integerlist', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->integerlist));
        {
          foreach ($this->integerlist as $iter187)
          {
            {
              $output->writeListBegin(TType::LST, count($iter187));
              {
                foreach ($iter187 as $iter188)
                {
                  {
                    $output->writeListBegin(TType::I32, count($iter188));
                    {
                      foreach ($iter188 as $iter189)
                      {
                        $xfer += $output->writeI32($iter189);
                      }
                    }
                    $output->writeListEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedMixedx2 {
  static $_TSPEC;

  /**
   * @var (int[])[]
   */
  public $int_set_list = null;
  /**
   * @var array
   */
  public $map_int_strset = null;
  /**
   * @var (array)[]
   */
  public $map_int_strset_list = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'int_set_list',
          'type' => TType::LST,
          'etype' => TType::SET,
          'elem' => array(
            'type' => TType::SET,
            'etype' => TType::I32,
            'elem' => array(
              'type' => TType::I32,
              ),
            ),
          ),
        2 => array(
          'var' => 'map_int_strset',
          'type' => TType::MAP,
          'ktype' => TType::I32,
          'vtype' => TType::SET,
          'key' => array(
            'type' => TType::I32,
          ),
          'val' => array(
            'type' => TType::SET,
            'etype' => TType::STRING,
            'elem' => array(
              'type' => TType::STRING,
              ),
            ),
          ),
        3 => array(
          'var' => 'map_int_strset_list',
          'type' => TType::LST,
          'etype' => TType::MAP,
          'elem' => array(
            'type' => TType::MAP,
            'ktype' => TType::I32,
            'vtype' => TType::SET,
            'key' => array(
              'type' => TType::I32,
            ),
            'val' => array(
              'type' => TType::SET,
              'etype' => TType::STRING,
              'elem' => array(
                'type' => TType::STRING,
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['int_set_list'])) {
        $this->int_set_list = $vals['int_set_list'];
      }
      if (isset($vals['map_int_strset'])) {
        $this->map_int_strset = $vals['map_int_strset'];
      }
      if (isset($vals['map_int_strset_list'])) {
        $this->map_int_strset_list = $vals['map_int_strset_list'];
      }
    }
  }

  public function getName() {
    return 'NestedMixedx2';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->int_set_list = array();
            $_size190 = 0;
            $_etype193 = 0;
            $xfer += $input->readListBegin($_etype193, $_size190);
            for ($_i194 = 0; $_i194 < $_size190; ++$_i194)
            {
              $elem195 = null;
              $elem195 = array();
              $_size196 = 0;
              $_etype199 = 0;
              $xfer += $input->readSetBegin($_etype199, $_size196);
              for ($_i200 = 0; $_i200 < $_size196; ++$_i200)
              {
                $elem201 = null;
                $xfer += $input->readI32($elem201);
                if (is_scalar($elem201)) {
                  $elem195[$elem201] = true;
                } else {
                  $elem195 []= $elem201;
                }
              }
              $xfer += $input->readSetEnd();
              $this->int_set_list []= $elem195;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::MAP) {
            $this->map_int_strset = array();
            $_size202 = 0;
            $_ktype203 = 0;
            $_vtype204 = 0;
            $xfer += $input->readMapBegin($_ktype203, $_vtype204, $_size202);
            for ($_i206 = 0; $_i206 < $_size202; ++$_i206)
            {
              $key207 = 0;
              $val208 = array();
              $xfer += $input->readI32($key207);
              $val208 = array();
              $_size209 = 0;
              $_etype212 = 0;
              $xfer += $input->readSetBegin($_etype212, $_size209);
              for ($_i213 = 0; $_i213 < $_size209; ++$_i213)
              {
                $elem214 = null;
                $xfer += $input->readString($elem214);
                if (is_scalar($elem214)) {
                  $val208[$elem214] = true;
                } else {
                  $val208 []= $elem214;
                }
              }
              $xfer += $input->readSetEnd();
              $this->map_int_strset[$key207] = $val208;
            }
            $xfer += $input->readMapEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 3:
          if ($ftype == TType::LST) {
            $this->map_int_strset_list = array();
            $_size215 = 0;
            $_etype218 = 0;
            $xfer += $input->readListBegin($_etype218, $_size215);
            for ($_i219 = 0; $_i219 < $_size215; ++$_i219)
            {
              $elem220 = null;
              $elem220 = array();
              $_size221 = 0;
              $_ktype222 = 0;
              $_vtype223 = 0;
              $xfer += $input->readMapBegin($_ktype222, $_vtype223, $_size221);
              for ($_i225 = 0; $_i225 < $_size221; ++$_i225)
              {
                $key226 = 0;
                $val227 = array();
                $xfer += $input->readI32($key226);
                $val227 = array();
                $_size228 = 0;
                $_etype231 = 0;
                $xfer += $input->readSetBegin($_etype231, $_size228);
                for ($_i232 = 0; $_i232 < $_size228; ++$_i232)
                {
                  $elem233 = null;
                  $xfer += $input->readString($elem233);
                  if (is_scalar($elem233)) {
                    $val227[$elem233] = true;
                  } else {
                    $val227 []= $elem233;
                  }
                }
                $xfer += $input->readSetEnd();
                $elem220[$key226] = $val227;
              }
              $xfer += $input->readMapEnd();
              $this->map_int_strset_list []= $elem220;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedMixedx2');
    if ($this->int_set_list !== null) {
      if (!is_array($this->int_set_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('int_set_list', TType::LST, 1);
      {
        $output->writeListBegin(TType::SET, count($this->int_set_list));
        {
          foreach ($this->int_set_list as $iter234)
          {
            {
              $output->writeSetBegin(TType::I32, count($iter234));
              {
                foreach ($iter234 as $iter235 => $iter236)
                {
                  if (is_scalar($iter236)) {
                  $xfer += $output->writeI32($iter235);
                  } else {
                  $xfer += $output->writeI32($iter236);
                  }
                }
              }
              $output->writeSetEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_int_strset !== null) {
      if (!is_array($this->map_int_strset)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_int_strset', TType::MAP, 2);
      {
        $output->writeMapBegin(TType::I32, TType::SET, count($this->map_int_strset));
        {
          foreach ($this->map_int_strset as $kiter237 => $viter238)
          {
            $xfer += $output->writeI32($kiter237);
            {
              $output->writeSetBegin(TType::STRING, count($viter238));
              {
                foreach ($viter238 as $iter239 => $iter240)
                {
                  if (is_scalar($iter240)) {
                  $xfer += $output->writeString($iter239);
                  } else {
                  $xfer += $output->writeString($iter240);
                  }
                }
              }
              $output->writeSetEnd();
            }
          }
        }
        $output->writeMapEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    if ($this->map_int_strset_list !== null) {
      if (!is_array($this->map_int_strset_list)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('map_int_strset_list', TType::LST, 3);
      {
        $output->writeListBegin(TType::MAP, count($this->map_int_strset_list));
        {
          foreach ($this->map_int_strset_list as $iter241)
          {
            {
              $output->writeMapBegin(TType::I32, TType::SET, count($iter241));
              {
                foreach ($iter241 as $kiter242 => $viter243)
                {
                  $xfer += $output->writeI32($kiter242);
                  {
                    $output->writeSetBegin(TType::STRING, count($viter243));
                    {
                      foreach ($viter243 as $iter244 => $iter245)
                      {
                        if (is_scalar($iter245)) {
                        $xfer += $output->writeString($iter244);
                        } else {
                        $xfer += $output->writeString($iter245);
                        }
                      }
                    }
                    $output->writeSetEnd();
                  }
                }
              }
              $output->writeMapEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class ListBonks {
  static $_TSPEC;

  /**
   * @var \ThriftTest\Bonk[]
   */
  public $bonk = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bonk',
          'type' => TType::LST,
          'etype' => TType::STRUCT,
          'elem' => array(
            'type' => TType::STRUCT,
            'class' => '\ThriftTest\Bonk',
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bonk'])) {
        $this->bonk = $vals['bonk'];
      }
    }
  }

  public function getName() {
    return 'ListBonks';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->bonk = array();
            $_size246 = 0;
            $_etype249 = 0;
            $xfer += $input->readListBegin($_etype249, $_size246);
            for ($_i250 = 0; $_i250 < $_size246; ++$_i250)
            {
              $elem251 = null;
              $elem251 = new \ThriftTest\Bonk();
              $xfer += $elem251->read($input);
              $this->bonk []= $elem251;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('ListBonks');
    if ($this->bonk !== null) {
      if (!is_array($this->bonk)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bonk', TType::LST, 1);
      {
        $output->writeListBegin(TType::STRUCT, count($this->bonk));
        {
          foreach ($this->bonk as $iter252)
          {
            $xfer += $iter252->write($output);
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class NestedListsBonk {
  static $_TSPEC;

  /**
   * @var ((\ThriftTest\Bonk[])[])[]
   */
  public $bonk = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'bonk',
          'type' => TType::LST,
          'etype' => TType::LST,
          'elem' => array(
            'type' => TType::LST,
            'etype' => TType::LST,
            'elem' => array(
              'type' => TType::LST,
              'etype' => TType::STRUCT,
              'elem' => array(
                'type' => TType::STRUCT,
                'class' => '\ThriftTest\Bonk',
                ),
              ),
            ),
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['bonk'])) {
        $this->bonk = $vals['bonk'];
      }
    }
  }

  public function getName() {
    return 'NestedListsBonk';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::LST) {
            $this->bonk = array();
            $_size253 = 0;
            $_etype256 = 0;
            $xfer += $input->readListBegin($_etype256, $_size253);
            for ($_i257 = 0; $_i257 < $_size253; ++$_i257)
            {
              $elem258 = null;
              $elem258 = array();
              $_size259 = 0;
              $_etype262 = 0;
              $xfer += $input->readListBegin($_etype262, $_size259);
              for ($_i263 = 0; $_i263 < $_size259; ++$_i263)
              {
                $elem264 = null;
                $elem264 = array();
                $_size265 = 0;
                $_etype268 = 0;
                $xfer += $input->readListBegin($_etype268, $_size265);
                for ($_i269 = 0; $_i269 < $_size265; ++$_i269)
                {
                  $elem270 = null;
                  $elem270 = new \ThriftTest\Bonk();
                  $xfer += $elem270->read($input);
                  $elem264 []= $elem270;
                }
                $xfer += $input->readListEnd();
                $elem258 []= $elem264;
              }
              $xfer += $input->readListEnd();
              $this->bonk []= $elem258;
            }
            $xfer += $input->readListEnd();
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('NestedListsBonk');
    if ($this->bonk !== null) {
      if (!is_array($this->bonk)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('bonk', TType::LST, 1);
      {
        $output->writeListBegin(TType::LST, count($this->bonk));
        {
          foreach ($this->bonk as $iter271)
          {
            {
              $output->writeListBegin(TType::LST, count($iter271));
              {
                foreach ($iter271 as $iter272)
                {
                  {
                    $output->writeListBegin(TType::STRUCT, count($iter272));
                    {
                      foreach ($iter272 as $iter273)
                      {
                        $xfer += $iter273->write($output);
                      }
                    }
                    $output->writeListEnd();
                  }
                }
              }
              $output->writeListEnd();
            }
          }
        }
        $output->writeListEnd();
      }
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class BoolTest {
  static $_TSPEC;

  /**
   * @var bool
   */
  public $b = true;
  /**
   * @var string
   */
  public $s = "true";

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'b',
          'type' => TType::BOOL,
          ),
        2 => array(
          'var' => 's',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['b'])) {
        $this->b = $vals['b'];
      }
      if (isset($vals['s'])) {
        $this->s = $vals['s'];
      }
    }
  }

  public function getName() {
    return 'BoolTest';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::BOOL) {
            $xfer += $input->readBool($this->b);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->s);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('BoolTest');
    if ($this->b !== null) {
      $xfer += $output->writeFieldBegin('b', TType::BOOL, 1);
      $xfer += $output->writeBool($this->b);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->s !== null) {
      $xfer += $output->writeFieldBegin('s', TType::STRING, 2);
      $xfer += $output->writeString($this->s);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StructA {
  static $_TSPEC;

  /**
   * @var string
   */
  public $s = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 's',
          'type' => TType::STRING,
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['s'])) {
        $this->s = $vals['s'];
      }
    }
  }

  public function getName() {
    return 'StructA';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRING) {
            $xfer += $input->readString($this->s);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StructA');
    if ($this->s !== null) {
      $xfer += $output->writeFieldBegin('s', TType::STRING, 1);
      $xfer += $output->writeString($this->s);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

class StructB {
  static $_TSPEC;

  /**
   * @var \ThriftTest\StructA
   */
  public $aa = null;
  /**
   * @var \ThriftTest\StructA
   */
  public $ab = null;

  public function __construct($vals=null) {
    if (!isset(self::$_TSPEC)) {
      self::$_TSPEC = array(
        1 => array(
          'var' => 'aa',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\StructA',
          ),
        2 => array(
          'var' => 'ab',
          'type' => TType::STRUCT,
          'class' => '\ThriftTest\StructA',
          ),
        );
    }
    if (is_array($vals)) {
      if (isset($vals['aa'])) {
        $this->aa = $vals['aa'];
      }
      if (isset($vals['ab'])) {
        $this->ab = $vals['ab'];
      }
    }
  }

  public function getName() {
    return 'StructB';
  }

  public function read($input)
  {
    $xfer = 0;
    $fname = null;
    $ftype = 0;
    $fid = 0;
    $xfer += $input->readStructBegin($fname);
    while (true)
    {
      $xfer += $input->readFieldBegin($fname, $ftype, $fid);
      if ($ftype == TType::STOP) {
        break;
      }
      switch ($fid)
      {
        case 1:
          if ($ftype == TType::STRUCT) {
            $this->aa = new \ThriftTest\StructA();
            $xfer += $this->aa->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        case 2:
          if ($ftype == TType::STRUCT) {
            $this->ab = new \ThriftTest\StructA();
            $xfer += $this->ab->read($input);
          } else {
            $xfer += $input->skip($ftype);
          }
          break;
        default:
          $xfer += $input->skip($ftype);
          break;
      }
      $xfer += $input->readFieldEnd();
    }
    $xfer += $input->readStructEnd();
    return $xfer;
  }

  public function write($output) {
    $xfer = 0;
    $xfer += $output->writeStructBegin('StructB');
    if ($this->aa !== null) {
      if (!is_object($this->aa)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('aa', TType::STRUCT, 1);
      $xfer += $this->aa->write($output);
      $xfer += $output->writeFieldEnd();
    }
    if ($this->ab !== null) {
      if (!is_object($this->ab)) {
        throw new TProtocolException('Bad type in structure.', TProtocolException::INVALID_DATA);
      }
      $xfer += $output->writeFieldBegin('ab', TType::STRUCT, 2);
      $xfer += $this->ab->write($output);
      $xfer += $output->writeFieldEnd();
    }
    $xfer += $output->writeFieldStop();
    $xfer += $output->writeStructEnd();
    return $xfer;
  }

}

final class Constant extends \Thrift\Type\TConstant {
  static protected $myNumberz;

  static protected function init_myNumberz() {
    return     1;
  }
}


